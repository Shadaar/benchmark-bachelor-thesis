//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Tue Jan 29 22:23:43 CET 2019
//
//
// Ports:
// Name                         I/O  size props
// axis_M_tvalid                  O     1
// axis_M_tdata                   O    64
// axis_M_tlast                   O     1
// axis_M_tuser                   O     1
// axis_M_tkeep                   O     8
// axis_M_tDest                   O     4
// axis_S_tready                  O     1
// axi4_S_arready                 O     1 reg
// axi4_S_rvalid                  O     1 reg
// axi4_S_rdata                   O    32
// axi4_S_rresp                   O     2
// axi4_S_awready                 O     1
// axi4_S_wready                  O     1
// axi4_S_bvalid                  O     1 reg
// axi4_S_bresp                   O     2
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axis_M_tready                  I     1
// axis_S_tvalid                  I     1
// axis_S_tdata                   I    64
// axis_S_tuser                   I     1
// axis_S_tkeep                   I     8
// axis_S_tDest                   I     4
// axis_S_tlast                   I     1
// axi4_S_arvalid                 I     1
// axi4_S_araddr                  I    12 reg
// axi4_S_arprot                  I     3 reg
// axi4_S_rready                  I     1
// axi4_S_awvalid                 I     1
// axi4_S_awaddr                  I    12
// axi4_S_awprot                  I     3
// axi4_S_wvalid                  I     1
// axi4_S_wdata                   I    32
// axi4_S_wstrb                   I     4
// axi4_S_bready                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkReply(CLK,
	       RST_N,

	       axis_M_tvalid,

	       axis_M_tready,

	       axis_M_tdata,

	       axis_M_tlast,

	       axis_M_tuser,

	       axis_M_tkeep,

	       axis_M_tDest,

	       axis_S_tready,

	       axis_S_tvalid,

	       axis_S_tdata,

	       axis_S_tuser,

	       axis_S_tkeep,

	       axis_S_tDest,

	       axis_S_tlast,

	       axi4_S_arready,

	       axi4_S_arvalid,

	       axi4_S_araddr,

	       axi4_S_arprot,

	       axi4_S_rvalid,

	       axi4_S_rready,

	       axi4_S_rdata,

	       axi4_S_rresp,

	       axi4_S_awready,

	       axi4_S_awvalid,

	       axi4_S_awaddr,

	       axi4_S_awprot,

	       axi4_S_wready,

	       axi4_S_wvalid,

	       axi4_S_wdata,

	       axi4_S_wstrb,

	       axi4_S_bvalid,

	       axi4_S_bready,

	       axi4_S_bresp);
  input  CLK;
  input  RST_N;

  // value method axis_M_tvalid
  output axis_M_tvalid;

  // action method axis_M_ptready
  input  axis_M_tready;

  // value method axis_M_tdata
  output [63 : 0] axis_M_tdata;

  // value method axis_M_tlast
  output axis_M_tlast;

  // value method axis_M_tuser
  output axis_M_tuser;

  // value method axis_M_tkeep
  output [7 : 0] axis_M_tkeep;

  // value method axis_M_tDest
  output [3 : 0] axis_M_tDest;

  // value method axis_S_tready
  output axis_S_tready;

  // action method axis_S_ptvalid
  input  axis_S_tvalid;

  // action method axis_S_ptdata
  input  [63 : 0] axis_S_tdata;

  // action method axis_S_ptuser
  input  axis_S_tuser;

  // action method axis_S_ptkeep
  input  [7 : 0] axis_S_tkeep;

  // action method axis_S_ptDest
  input  [3 : 0] axis_S_tDest;

  // action method axis_S_ptlast
  input  axis_S_tlast;

  // value method axi4_S_read_arready
  output axi4_S_arready;

  // action method axi4_S_read_parvalid
  input  axi4_S_arvalid;

  // action method axi4_S_read_paraddr
  input  [11 : 0] axi4_S_araddr;

  // action method axi4_S_read_parprot
  input  [2 : 0] axi4_S_arprot;

  // value method axi4_S_read_rvalid
  output axi4_S_rvalid;

  // action method axi4_S_read_prready
  input  axi4_S_rready;

  // value method axi4_S_read_rdata
  output [31 : 0] axi4_S_rdata;

  // value method axi4_S_read_rresp
  output [1 : 0] axi4_S_rresp;

  // value method axi4_S_write_awready
  output axi4_S_awready;

  // action method axi4_S_write_pawvalid
  input  axi4_S_awvalid;

  // action method axi4_S_write_pawaddr
  input  [11 : 0] axi4_S_awaddr;

  // action method axi4_S_write_pawprot
  input  [2 : 0] axi4_S_awprot;

  // value method axi4_S_write_wready
  output axi4_S_wready;

  // action method axi4_S_write_pwvalid
  input  axi4_S_wvalid;

  // action method axi4_S_write_pwdata
  input  [31 : 0] axi4_S_wdata;

  // action method axi4_S_write_pwstrb
  input  [3 : 0] axi4_S_wstrb;

  // value method axi4_S_write_bvalid
  output axi4_S_bvalid;

  // action method axi4_S_write_pbready
  input  axi4_S_bready;

  // value method axi4_S_write_bresp
  output [1 : 0] axi4_S_bresp;

  // signals for module outputs
  wire [63 : 0] axis_M_tdata;
  wire [31 : 0] axi4_S_rdata;
  wire [7 : 0] axis_M_tkeep;
  wire [3 : 0] axis_M_tDest;
  wire [1 : 0] axi4_S_bresp, axi4_S_rresp;
  wire axi4_S_arready,
       axi4_S_awready,
       axi4_S_bvalid,
       axi4_S_rvalid,
       axi4_S_wready,
       axis_M_tlast,
       axis_M_tuser,
       axis_M_tvalid,
       axis_S_tready;

  // inlined wires
  wire [78 : 0] streamIn_in_1_rv$port1__read,
		streamIn_in_1_rv$port1__write_1,
		streamIn_in_1_rv$port2__read,
		streamOut_out_1_rv$port1__read,
		streamOut_out_1_rv$port1__write_1,
		streamOut_out_1_rv$port2__read;
  wire [77 : 0] next_enqw$wget;
  wire [36 : 0] axiw_dataIn_rv$port0__write_1,
		axiw_dataIn_rv$port1__read,
		axiw_dataIn_rv$port2__read;
  wire [15 : 0] axiw_addrIn_rv$port0__write_1,
		axiw_addrIn_rv$port1__read,
		axiw_addrIn_rv$port2__read;
  wire axiw_addrIn_rv$EN_port0__write,
       axiw_addrIn_rv$EN_port1__write,
       axiw_dataIn_rv$EN_port0__write,
       axiw_dataIn_rv$EN_port1__write,
       next_dequeueing$whas,
       next_enqw$whas,
       streamIn_in_1_rv$EN_port0__write,
       streamIn_in_1_rv$EN_port1__write,
       streamOut_out_1_rv$EN_port0__write,
       streamOut_out_1_rv$EN_port1__write;

  // register axiw_addrIn_rv
  reg [15 : 0] axiw_addrIn_rv;
  wire [15 : 0] axiw_addrIn_rv$D_IN;
  wire axiw_addrIn_rv$EN;

  // register axiw_dataIn_rv
  reg [36 : 0] axiw_dataIn_rv;
  wire [36 : 0] axiw_dataIn_rv$D_IN;
  wire axiw_dataIn_rv$EN;

  // register buffer
  reg [77 : 0] buffer;
  wire [77 : 0] buffer$D_IN;
  wire buffer$EN;

  // register counter
  reg [31 : 0] counter;
  wire [31 : 0] counter$D_IN;
  wire counter$EN;

  // register debug_first
  reg [63 : 0] debug_first;
  wire [63 : 0] debug_first$D_IN;
  wire debug_first$EN;

  // register debug_four
  reg [63 : 0] debug_four;
  wire [63 : 0] debug_four$D_IN;
  wire debug_four$EN;

  // register debug_second
  reg [63 : 0] debug_second;
  wire [63 : 0] debug_second$D_IN;
  wire debug_second$EN;

  // register debug_third
  reg [63 : 0] debug_third;
  wire [63 : 0] debug_third$D_IN;
  wire debug_third$EN;

  // register done
  reg done;
  wire done$D_IN, done$EN;

  // register reading
  reg [31 : 0] reading;
  reg [31 : 0] reading$D_IN;
  wire reading$EN;

  // register streamIn_in_1_rv
  reg [78 : 0] streamIn_in_1_rv;
  wire [78 : 0] streamIn_in_1_rv$D_IN;
  wire streamIn_in_1_rv$EN;

  // register streamOut_out_1_rv
  reg [78 : 0] streamOut_out_1_rv;
  wire [78 : 0] streamOut_out_1_rv$D_IN;
  wire streamOut_out_1_rv$EN;

  // ports of submodule axir_in
  wire [14 : 0] axir_in$D_IN, axir_in$D_OUT;
  wire axir_in$CLR, axir_in$DEQ, axir_in$EMPTY_N, axir_in$ENQ, axir_in$FULL_N;

  // ports of submodule axir_out
  wire [33 : 0] axir_out$D_IN, axir_out$D_OUT;
  wire axir_out$CLR,
       axir_out$DEQ,
       axir_out$EMPTY_N,
       axir_out$ENQ,
       axir_out$FULL_N;

  // ports of submodule axiw_in
  wire [50 : 0] axiw_in$D_IN;
  wire axiw_in$CLR, axiw_in$DEQ, axiw_in$EMPTY_N, axiw_in$ENQ, axiw_in$FULL_N;

  // ports of submodule axiw_out
  wire [1 : 0] axiw_out$D_IN, axiw_out$D_OUT;
  wire axiw_out$CLR,
       axiw_out$DEQ,
       axiw_out$EMPTY_N,
       axiw_out$ENQ,
       axiw_out$FULL_N;

  // ports of submodule next_ff
  wire [77 : 0] next_ff$D_IN, next_ff$D_OUT;
  wire next_ff$CLR, next_ff$DEQ, next_ff$EMPTY_N, next_ff$ENQ, next_ff$FULL_N;

  // ports of submodule next_firstValid
  wire next_firstValid$D_IN, next_firstValid$EN, next_firstValid$Q_OUT;

  // ports of submodule streamIn_in
  wire [77 : 0] streamIn_in$D_IN;
  wire streamIn_in$CLR, streamIn_in$DEQ, streamIn_in$ENQ;

  // ports of submodule streamOut_out
  wire [77 : 0] streamOut_out$D_IN;
  wire streamOut_out$CLR, streamOut_out$DEQ, streamOut_out$ENQ;

  // rule scheduling signals
  wire WILL_FIRE_RL_axi_stream_read0,
       WILL_FIRE_RL_axi_stream_read1,
       WILL_FIRE_RL_axi_stream_read2,
       WILL_FIRE_RL_axi_stream_read3;

  // inputs to muxes for submodule ports
  wire [77 : 0] MUX_buffer$write_1__VAL_2, MUX_next_enqw$wset_1__VAL_2;
  wire MUX_buffer$write_1__SEL_1,
       MUX_done$write_1__SEL_1,
       MUX_next_enqw$wset_1__SEL_1;

  // remaining internal signals
  reg [31 : 0] x_data__h7225;
  wire [63 : 0] x__h6347, x_data__h6648, x_data__h7054;
  wire [47 : 0] dest__h6334;
  wire [13 : 0] _0_CONCAT_IF_next_ff_i_notEmpty__8_THEN_next_ff_ETC___d146;
  wire [7 : 0] x_keep__h7056;

  // value method axis_M_tvalid
  assign axis_M_tvalid = streamOut_out_1_rv[78] ;

  // value method axis_M_tdata
  assign axis_M_tdata =
	     streamOut_out_1_rv[78] ? streamOut_out_1_rv[77:14] : 64'd0 ;

  // value method axis_M_tlast
  assign axis_M_tlast = streamOut_out_1_rv[78] && streamOut_out_1_rv[0] ;

  // value method axis_M_tuser
  assign axis_M_tuser = streamOut_out_1_rv[78] && streamOut_out_1_rv[13] ;

  // value method axis_M_tkeep
  assign axis_M_tkeep =
	     streamOut_out_1_rv[78] ? streamOut_out_1_rv[12:5] : 8'd0 ;

  // value method axis_M_tDest
  assign axis_M_tDest =
	     streamOut_out_1_rv[78] ? streamOut_out_1_rv[4:1] : 4'd0 ;

  // value method axis_S_tready
  assign axis_S_tready = !streamIn_in_1_rv$port1__read[78] ;

  // value method axi4_S_read_arready
  assign axi4_S_arready = axir_in$FULL_N ;

  // value method axi4_S_read_rvalid
  assign axi4_S_rvalid = axir_out$EMPTY_N ;

  // value method axi4_S_read_rdata
  assign axi4_S_rdata = axir_out$EMPTY_N ? axir_out$D_OUT[33:2] : 32'd0 ;

  // value method axi4_S_read_rresp
  assign axi4_S_rresp = axir_out$EMPTY_N ? axir_out$D_OUT[1:0] : 2'd0 ;

  // value method axi4_S_write_awready
  assign axi4_S_awready = !axiw_addrIn_rv[15] ;

  // value method axi4_S_write_wready
  assign axi4_S_wready = !axiw_dataIn_rv[36] ;

  // value method axi4_S_write_bvalid
  assign axi4_S_bvalid = axiw_out$EMPTY_N ;

  // value method axi4_S_write_bresp
  assign axi4_S_bresp = axiw_out$EMPTY_N ? axiw_out$D_OUT : 2'd0 ;

  // submodule axir_in
  FIFO1 #(.width(32'd15), .guarded(32'd1)) axir_in(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(axir_in$D_IN),
						   .ENQ(axir_in$ENQ),
						   .DEQ(axir_in$DEQ),
						   .CLR(axir_in$CLR),
						   .D_OUT(axir_in$D_OUT),
						   .FULL_N(axir_in$FULL_N),
						   .EMPTY_N(axir_in$EMPTY_N));

  // submodule axir_out
  FIFO1 #(.width(32'd34), .guarded(32'd1)) axir_out(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(axir_out$D_IN),
						    .ENQ(axir_out$ENQ),
						    .DEQ(axir_out$DEQ),
						    .CLR(axir_out$CLR),
						    .D_OUT(axir_out$D_OUT),
						    .FULL_N(axir_out$FULL_N),
						    .EMPTY_N(axir_out$EMPTY_N));

  // submodule axiw_in
  FIFO1 #(.width(32'd51), .guarded(32'd1)) axiw_in(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(axiw_in$D_IN),
						   .ENQ(axiw_in$ENQ),
						   .DEQ(axiw_in$DEQ),
						   .CLR(axiw_in$CLR),
						   .D_OUT(),
						   .FULL_N(axiw_in$FULL_N),
						   .EMPTY_N(axiw_in$EMPTY_N));

  // submodule axiw_out
  FIFO1 #(.width(32'd2), .guarded(32'd1)) axiw_out(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(axiw_out$D_IN),
						   .ENQ(axiw_out$ENQ),
						   .DEQ(axiw_out$DEQ),
						   .CLR(axiw_out$CLR),
						   .D_OUT(axiw_out$D_OUT),
						   .FULL_N(axiw_out$FULL_N),
						   .EMPTY_N(axiw_out$EMPTY_N));

  // submodule next_ff
  SizedFIFO #(.p1width(32'd78),
	      .p2depth(32'd1200),
	      .p3cntr_width(32'd11),
	      .guarded(32'd0)) next_ff(.RST(RST_N),
				       .CLK(CLK),
				       .D_IN(next_ff$D_IN),
				       .ENQ(next_ff$ENQ),
				       .DEQ(next_ff$DEQ),
				       .CLR(next_ff$CLR),
				       .D_OUT(next_ff$D_OUT),
				       .FULL_N(next_ff$FULL_N),
				       .EMPTY_N(next_ff$EMPTY_N));

  // submodule next_firstValid
  RevertReg #(.width(32'd1), .init(1'd1)) next_firstValid(.CLK(CLK),
							  .D_IN(next_firstValid$D_IN),
							  .EN(next_firstValid$EN),
							  .Q_OUT(next_firstValid$Q_OUT));

  // submodule streamIn_in
  FIFO1 #(.width(32'd78), .guarded(32'd1)) streamIn_in(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(streamIn_in$D_IN),
						       .ENQ(streamIn_in$ENQ),
						       .DEQ(streamIn_in$DEQ),
						       .CLR(streamIn_in$CLR),
						       .D_OUT(),
						       .FULL_N(),
						       .EMPTY_N());

  // submodule streamOut_out
  FIFO1 #(.width(32'd78), .guarded(32'd1)) streamOut_out(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(streamOut_out$D_IN),
							 .ENQ(streamOut_out$ENQ),
							 .DEQ(streamOut_out$DEQ),
							 .CLR(streamOut_out$CLR),
							 .D_OUT(),
							 .FULL_N(),
							 .EMPTY_N());

  // rule RL_axi_stream_read2
  assign WILL_FIRE_RL_axi_stream_read2 =
	     streamIn_in_1_rv[78] && next_ff$FULL_N && reading == 32'd2 &&
	     !done ;

  // rule RL_axi_stream_read1
  assign WILL_FIRE_RL_axi_stream_read1 =
	     streamIn_in_1_rv[78] && next_ff$FULL_N && reading == 32'd1 &&
	     !done ;

  // rule RL_axi_stream_read3
  assign WILL_FIRE_RL_axi_stream_read3 = next_ff$FULL_N && done ;

  // rule RL_axi_stream_read0
  assign WILL_FIRE_RL_axi_stream_read0 =
	     streamIn_in_1_rv[78] && reading == 32'd0 && next_ff$FULL_N ;

  // inputs to muxes for submodule ports
  assign MUX_buffer$write_1__SEL_1 =
	     WILL_FIRE_RL_axi_stream_read2 || WILL_FIRE_RL_axi_stream_read0 ;
  assign MUX_done$write_1__SEL_1 =
	     WILL_FIRE_RL_axi_stream_read2 && streamIn_in_1_rv[0] ;
  assign MUX_next_enqw$wset_1__SEL_1 =
	     WILL_FIRE_RL_axi_stream_read3 || WILL_FIRE_RL_axi_stream_read2 ;
  assign MUX_buffer$write_1__VAL_2 = { x__h6347, streamIn_in_1_rv[13:0] } ;
  assign MUX_next_enqw$wset_1__VAL_2 = { x_data__h6648, buffer[13:0] } ;

  // inlined wires
  assign next_enqw$wget =
	     MUX_next_enqw$wset_1__SEL_1 ?
	       buffer :
	       MUX_next_enqw$wset_1__VAL_2 ;
  assign next_enqw$whas =
	     WILL_FIRE_RL_axi_stream_read3 || WILL_FIRE_RL_axi_stream_read2 ||
	     WILL_FIRE_RL_axi_stream_read1 ;
  assign next_dequeueing$whas =
	     next_firstValid$Q_OUT && (next_ff$EMPTY_N || next_enqw$whas) &&
	     !streamOut_out_1_rv$port1__read[78] ;
  assign streamOut_out_1_rv$EN_port0__write =
	     streamOut_out_1_rv[78] && axis_M_tready ;
  assign streamOut_out_1_rv$port1__read =
	     streamOut_out_1_rv$EN_port0__write ?
	       79'h2AAAAAAAAAAAAAAAAAAA :
	       streamOut_out_1_rv ;
  assign streamOut_out_1_rv$EN_port1__write =
	     next_firstValid$Q_OUT && (next_ff$EMPTY_N || next_enqw$whas) &&
	     !streamOut_out_1_rv$port1__read[78] ;
  assign streamOut_out_1_rv$port1__write_1 =
	     { 1'd1,
	       x_data__h7054,
	       _0_CONCAT_IF_next_ff_i_notEmpty__8_THEN_next_ff_ETC___d146 } ;
  assign streamOut_out_1_rv$port2__read =
	     streamOut_out_1_rv$EN_port1__write ?
	       streamOut_out_1_rv$port1__write_1 :
	       streamOut_out_1_rv$port1__read ;
  assign streamIn_in_1_rv$EN_port0__write =
	     WILL_FIRE_RL_axi_stream_read2 || WILL_FIRE_RL_axi_stream_read1 ||
	     WILL_FIRE_RL_axi_stream_read0 ;
  assign streamIn_in_1_rv$port1__read =
	     streamIn_in_1_rv$EN_port0__write ?
	       79'h2AAAAAAAAAAAAAAAAAAA :
	       streamIn_in_1_rv ;
  assign streamIn_in_1_rv$EN_port1__write =
	     !streamIn_in_1_rv$port1__read[78] && axis_S_tvalid ;
  assign streamIn_in_1_rv$port1__write_1 =
	     { 1'd1,
	       axis_S_tdata,
	       axis_S_tuser,
	       axis_S_tkeep,
	       axis_S_tDest,
	       axis_S_tlast } ;
  assign streamIn_in_1_rv$port2__read =
	     streamIn_in_1_rv$EN_port1__write ?
	       streamIn_in_1_rv$port1__write_1 :
	       streamIn_in_1_rv$port1__read ;
  assign axiw_addrIn_rv$EN_port0__write =
	     !axiw_addrIn_rv[15] && axi4_S_awvalid ;
  assign axiw_addrIn_rv$port0__write_1 =
	     { 1'd1, axi4_S_awaddr, axi4_S_awprot } ;
  assign axiw_addrIn_rv$port1__read =
	     axiw_addrIn_rv$EN_port0__write ?
	       axiw_addrIn_rv$port0__write_1 :
	       axiw_addrIn_rv ;
  assign axiw_addrIn_rv$EN_port1__write =
	     axiw_addrIn_rv$port1__read[15] &&
	     axiw_dataIn_rv$port1__read[36] &&
	     axiw_in$FULL_N ;
  assign axiw_addrIn_rv$port2__read =
	     axiw_addrIn_rv$EN_port1__write ?
	       16'd10922 :
	       axiw_addrIn_rv$port1__read ;
  assign axiw_dataIn_rv$EN_port0__write =
	     !axiw_dataIn_rv[36] && axi4_S_wvalid ;
  assign axiw_dataIn_rv$port0__write_1 =
	     { 1'd1, axi4_S_wdata, axi4_S_wstrb } ;
  assign axiw_dataIn_rv$port1__read =
	     axiw_dataIn_rv$EN_port0__write ?
	       axiw_dataIn_rv$port0__write_1 :
	       axiw_dataIn_rv ;
  assign axiw_dataIn_rv$EN_port1__write =
	     axiw_addrIn_rv$port1__read[15] &&
	     axiw_dataIn_rv$port1__read[36] &&
	     axiw_in$FULL_N ;
  assign axiw_dataIn_rv$port2__read =
	     axiw_dataIn_rv$EN_port1__write ?
	       37'h0AAAAAAAAA :
	       axiw_dataIn_rv$port1__read ;

  // register axiw_addrIn_rv
  assign axiw_addrIn_rv$D_IN = axiw_addrIn_rv$port2__read ;
  assign axiw_addrIn_rv$EN = 1'b1 ;

  // register axiw_dataIn_rv
  assign axiw_dataIn_rv$D_IN = axiw_dataIn_rv$port2__read ;
  assign axiw_dataIn_rv$EN = 1'b1 ;

  // register buffer
  assign buffer$D_IN =
	     MUX_buffer$write_1__SEL_1 ?
	       streamIn_in_1_rv[77:0] :
	       MUX_buffer$write_1__VAL_2 ;
  assign buffer$EN =
	     WILL_FIRE_RL_axi_stream_read2 || WILL_FIRE_RL_axi_stream_read0 ||
	     WILL_FIRE_RL_axi_stream_read1 ;

  // register counter
  assign counter$D_IN = counter + 32'd1 ;
  assign counter$EN = WILL_FIRE_RL_axi_stream_read3 ;

  // register debug_first
  assign debug_first$D_IN = streamIn_in_1_rv[77:14] ;
  assign debug_first$EN = WILL_FIRE_RL_axi_stream_read0 ;

  // register debug_four
  assign debug_four$D_IN = { debug_four[63:48], buffer[61:14] } ;
  assign debug_four$EN = WILL_FIRE_RL_axi_stream_read1 ;

  // register debug_second
  assign debug_second$D_IN = x__h6347 ;
  assign debug_second$EN = WILL_FIRE_RL_axi_stream_read1 ;

  // register debug_third
  assign debug_third$D_IN = { debug_third[63:48], dest__h6334 } ;
  assign debug_third$EN = WILL_FIRE_RL_axi_stream_read1 ;

  // register done
  assign done$D_IN = MUX_done$write_1__SEL_1 ;
  assign done$EN =
	     WILL_FIRE_RL_axi_stream_read2 && streamIn_in_1_rv[0] ||
	     WILL_FIRE_RL_axi_stream_read3 ;

  // register reading
  always@(MUX_done$write_1__SEL_1 or
	  WILL_FIRE_RL_axi_stream_read0 or WILL_FIRE_RL_axi_stream_read1)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_done$write_1__SEL_1: reading$D_IN = 32'd0;
      WILL_FIRE_RL_axi_stream_read0: reading$D_IN = 32'd1;
      WILL_FIRE_RL_axi_stream_read1: reading$D_IN = 32'd2;
      default: reading$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign reading$EN =
	     WILL_FIRE_RL_axi_stream_read2 && streamIn_in_1_rv[0] ||
	     WILL_FIRE_RL_axi_stream_read0 ||
	     WILL_FIRE_RL_axi_stream_read1 ;

  // register streamIn_in_1_rv
  assign streamIn_in_1_rv$D_IN = streamIn_in_1_rv$port2__read ;
  assign streamIn_in_1_rv$EN = 1'b1 ;

  // register streamOut_out_1_rv
  assign streamOut_out_1_rv$D_IN = streamOut_out_1_rv$port2__read ;
  assign streamOut_out_1_rv$EN = 1'b1 ;

  // submodule axir_in
  assign axir_in$D_IN = { axi4_S_araddr, axi4_S_arprot } ;
  assign axir_in$ENQ = axir_in$FULL_N && axi4_S_arvalid ;
  assign axir_in$DEQ = axir_in$EMPTY_N && axir_out$FULL_N ;
  assign axir_in$CLR = 1'b0 ;

  // submodule axir_out
  assign axir_out$D_IN = { x_data__h7225, 2'd0 } ;
  assign axir_out$ENQ = axir_in$EMPTY_N && axir_out$FULL_N ;
  assign axir_out$DEQ = axir_out$EMPTY_N && axi4_S_rready ;
  assign axir_out$CLR = 1'b0 ;

  // submodule axiw_in
  assign axiw_in$D_IN =
	     { axiw_addrIn_rv$port1__read[14:3],
	       axiw_dataIn_rv$port1__read[35:0],
	       axiw_addrIn_rv$port1__read[2:0] } ;
  assign axiw_in$ENQ =
	     axiw_addrIn_rv$port1__read[15] &&
	     axiw_dataIn_rv$port1__read[36] &&
	     axiw_in$FULL_N ;
  assign axiw_in$DEQ = axiw_in$EMPTY_N && axiw_out$FULL_N ;
  assign axiw_in$CLR = 1'b0 ;

  // submodule axiw_out
  assign axiw_out$D_IN = 2'd0 ;
  assign axiw_out$ENQ = axiw_in$EMPTY_N && axiw_out$FULL_N ;
  assign axiw_out$DEQ = axiw_out$EMPTY_N && axi4_S_bready ;
  assign axiw_out$CLR = 1'b0 ;

  // submodule next_ff
  assign next_ff$D_IN = next_enqw$wget ;
  assign next_ff$ENQ =
	     next_enqw$whas && (!next_dequeueing$whas || next_ff$EMPTY_N) ;
  assign next_ff$DEQ = next_dequeueing$whas && next_ff$EMPTY_N ;
  assign next_ff$CLR = 1'b0 ;

  // submodule next_firstValid
  assign next_firstValid$D_IN = 1'd1 ;
  assign next_firstValid$EN = next_dequeueing$whas ;

  // submodule streamIn_in
  assign streamIn_in$D_IN = 78'h0 ;
  assign streamIn_in$ENQ = 1'b0 ;
  assign streamIn_in$DEQ = 1'b0 ;
  assign streamIn_in$CLR = 1'b0 ;

  // submodule streamOut_out
  assign streamOut_out$D_IN = 78'h0 ;
  assign streamOut_out$ENQ = 1'b0 ;
  assign streamOut_out$DEQ = 1'b0 ;
  assign streamOut_out$CLR = 1'b0 ;

  // remaining internal signals
  assign _0_CONCAT_IF_next_ff_i_notEmpty__8_THEN_next_ff_ETC___d146 =
	     { 1'd0,
	       x_keep__h7056,
	       4'd0,
	       next_ff$EMPTY_N ? next_ff$D_OUT[0] : next_enqw$wget[0] } ;
  assign dest__h6334 = { streamIn_in_1_rv[45:14], buffer[77:62] } ;
  assign x__h6347 = { streamIn_in_1_rv[77:46], buffer[61:30] } ;
  assign x_data__h6648 = { buffer[29:14], dest__h6334 } ;
  assign x_data__h7054 =
	     next_ff$EMPTY_N ? next_ff$D_OUT[77:14] : next_enqw$wget[77:14] ;
  assign x_keep__h7056 =
	     next_ff$EMPTY_N ? next_ff$D_OUT[12:5] : next_enqw$wget[12:5] ;
  always@(axir_in$D_OUT or
	  counter or debug_first or debug_second or debug_third or debug_four)
  begin
    case (axir_in$D_OUT[14:3])
      12'd0: x_data__h7225 = debug_first[31:0];
      12'd4: x_data__h7225 = debug_first[63:32];
      12'd8: x_data__h7225 = debug_second[31:0];
      12'd12: x_data__h7225 = debug_second[63:32];
      12'd16: x_data__h7225 = debug_third[31:0];
      12'd20: x_data__h7225 = debug_third[63:32];
      12'd24: x_data__h7225 = debug_four[31:0];
      12'd28: x_data__h7225 = debug_four[63:32];
      default: x_data__h7225 = counter;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        axiw_addrIn_rv <= `BSV_ASSIGNMENT_DELAY 16'd10922;
	axiw_dataIn_rv <= `BSV_ASSIGNMENT_DELAY 37'h0AAAAAAAAA;
	buffer <= `BSV_ASSIGNMENT_DELAY 78'h0DCD8D4D0CCC8C4C1FE0;
	counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	debug_first <= `BSV_ASSIGNMENT_DELAY 64'd0;
	debug_four <= `BSV_ASSIGNMENT_DELAY 64'd0;
	debug_second <= `BSV_ASSIGNMENT_DELAY 64'd0;
	debug_third <= `BSV_ASSIGNMENT_DELAY 64'd0;
	done <= `BSV_ASSIGNMENT_DELAY 1'd0;
	reading <= `BSV_ASSIGNMENT_DELAY 32'd0;
	streamIn_in_1_rv <= `BSV_ASSIGNMENT_DELAY 79'h2AAAAAAAAAAAAAAAAAAA;
	streamOut_out_1_rv <= `BSV_ASSIGNMENT_DELAY 79'h2AAAAAAAAAAAAAAAAAAA;
      end
    else
      begin
        if (axiw_addrIn_rv$EN)
	  axiw_addrIn_rv <= `BSV_ASSIGNMENT_DELAY axiw_addrIn_rv$D_IN;
	if (axiw_dataIn_rv$EN)
	  axiw_dataIn_rv <= `BSV_ASSIGNMENT_DELAY axiw_dataIn_rv$D_IN;
	if (buffer$EN) buffer <= `BSV_ASSIGNMENT_DELAY buffer$D_IN;
	if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
	if (debug_first$EN)
	  debug_first <= `BSV_ASSIGNMENT_DELAY debug_first$D_IN;
	if (debug_four$EN)
	  debug_four <= `BSV_ASSIGNMENT_DELAY debug_four$D_IN;
	if (debug_second$EN)
	  debug_second <= `BSV_ASSIGNMENT_DELAY debug_second$D_IN;
	if (debug_third$EN)
	  debug_third <= `BSV_ASSIGNMENT_DELAY debug_third$D_IN;
	if (done$EN) done <= `BSV_ASSIGNMENT_DELAY done$D_IN;
	if (reading$EN) reading <= `BSV_ASSIGNMENT_DELAY reading$D_IN;
	if (streamIn_in_1_rv$EN)
	  streamIn_in_1_rv <= `BSV_ASSIGNMENT_DELAY streamIn_in_1_rv$D_IN;
	if (streamOut_out_1_rv$EN)
	  streamOut_out_1_rv <= `BSV_ASSIGNMENT_DELAY streamOut_out_1_rv$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    axiw_addrIn_rv = 16'hAAAA;
    axiw_dataIn_rv = 37'h0AAAAAAAAA;
    buffer = 78'h2AAAAAAAAAAAAAAAAAAA;
    counter = 32'hAAAAAAAA;
    debug_first = 64'hAAAAAAAAAAAAAAAA;
    debug_four = 64'hAAAAAAAAAAAAAAAA;
    debug_second = 64'hAAAAAAAAAAAAAAAA;
    debug_third = 64'hAAAAAAAAAAAAAAAA;
    done = 1'h0;
    reading = 32'hAAAAAAAA;
    streamIn_in_1_rv = 79'h2AAAAAAAAAAAAAAAAAAA;
    streamOut_out_1_rv = 79'h2AAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkReply

